# Рефлексия

В данном занятии нам необходимо сделать элиминацию хвостовой рекурсии для алгоритма сортировки Хоара.

Смысл элиминации хвостовой рекурсии:

- ***сведение вычслений до цепочки, исключая ветвления в функции, когда ты не до конца можешь гарантировать результат вызова очередной рекурсии***

В данном занятии необходимо переписать алгоритм быстрой сортировки Хоана с хвостовой рекурсией.

Если рассмотреть наш алгоритм, то можно увидеть, что у нас нет хвостовой рекурсии именно в этих моментах:

```python
if left < right:
        basic_indx = ArrayChunk(array, left, right)
        
        QuickSort(array, left, basic_indx-1)
        QuickSort(array, basic_indx+1, right)
```

то есть функция не заканчивается рекурсией.

Первая мысль:
- можно передавать в функцию разбиения массива, для левой части и для правой, как делали в прошлом занятии, только вызовы функций должны быть из разных условий, так получается что наша функция заканчивается одним рекурсивным вызовом, либо левая половина, либо правая
- условия берем относительно выпавшего опорного индекса

Получается вот так:

```python
# t = O(n*log(n)), n - len of array
# m = O(log(n))
def QuickSortTailOptimization(array : list[int], left : int, right : int):
    size = len(array)
    if size < 2:
        return

    while left < right:
        basic_indx = ArrayChunk(array, left, right)

        if basic_indx - left < right - basic_indx: # если опорный указатель больше выпал а левую сторону -> идем влево
            QuickSortTailOptimization(array, left, basic_indx-1)
            left = basic_indx + 1 # обновляем, чтобы потом уйти в правую часть
        else: # иначе вправо
            QuickSortTailOptimization(array, basic_indx+1, right)
            right = basic_indx - 1 # здесь чтобы уйти в левую часть
```

Важное замечание в том что необходимо использовать цикл, таким образом мы будем обрабатывать все вызовы в рамках первого вызового, тогда размер стека будет компенсирован, за счет цикла, выглядит это примерно вот так:

Пример:

### `[4, 2, 6, 1, 3, 5, 7]`

Без цикла и хвостовой рекурсии:

```
QuickSort(0, 6)  ← Стек: 1
  ├─ QuickSort(0, 2)  ← Стек: 2
  │   ├─ QuickSort(0, 0)  ← Стек: 3
  │   └─ QuickSort(2, 2)  ← Стек: 3
  └─ QuickSort(4, 6)  ← Стек: 2
      ├─ QuickSort(4, 4)  ← Стек: 3
      └─ QuickSort(6, 6)  ← Стек: 3
```

С циклом и хвостовой рекурсией:

```
QuickSort(0, 6)  ← Стек: 1
  └─ QuickSort(0, 2)  ← Стек: 2 (рекурсия для меньшей части)
      └─ QuickSort(0, 0)  ← Стек: 3
  # Цикл обрабатывает (3, 6), (4, 6) без новых вызовов
      └─ QuickSort(4, 4)  ← Стек: 2
```
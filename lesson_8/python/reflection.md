# Рефлексия

## MergeSort

В данном занятии мы разобрали алгоритм сортировки слиянием, суть заключается в том, чтобы объединить две отсортированные половины одного массива, используя технику "разделяй и властвуй" - то есть когда мы дробим задачу на элементарные еденицы, а уже потом беремся за решение элементарных единиц, сам алгоритм:

#### Разделяй:
1. В функцию перелается массив, если его длина меньше 2, не включительно - тогда наш алгоритм завершается
2. Делим исходный массив на две половины и рекурсивно вызываем нашу функцию последовательно для каждой из половин
3. На выходе у нас получится две отсортированных половины, далее нам необходимо их объединить

#### Властвуй:
1. Создаем массив, который будет являться рещультатом
2. Проходимся последовательно по двум массивам и определяем целевой элеиент для построения упорядоченной последовательности
3. Если после прохода в массивах есть еще элементы, тогда мы проходимся поочередно по каждому из них и вливаем остатки из массивов в итоговый
4. Возвращаем итоговый массив

Проблема модификации данного алгоритма в том, что мы много аллоцируем памяти на массивы, создавая новые.

## K-way Merge-Sort

Также есть еще одна модификация данного алгоритма, который подразумевает деление на K массивов и последующее их объединение, но в данном случае необходимо оптимизация, так как в случае больших массивов и их частей - получается что мы выделем очень много памяти!

> Однако добавлять к общей сложности ещё k итераций на каждый элемент оказывается накладным, поэтому были придуманы различные более эффективные алгоритмы, или даже эвристики. Так, можно создать k буферов в оперативной памяти, и подкачивать в них данные из файлов уже большими порциями. Большой выигрыш дают подходы, когда в дополнение к "сырым" данным мы храним ещё и мета-информацию, например, индексы сортировки.
> 
> Очевидный недостаток данного подхода в том, что результат надо хранить в массиве, и если на вход подаётся много крупных массивов, то и результирующий набор данных получается очень большой, но при этом он по сути временный.

## Сорировка кучей

Для следующей концепции решили использовать такую структуру данных как куча, с помощью который можно получать приоритетный (максимальный/мимниальный) элемент за O(1)

> Одна из наиболее эффективных реализаций K-way Merge-Sort основана на использовании кучи (пирамиды), которая позволяет за O(1) получить доступ к максимальному элементу (или к минимальному, но не одновременно к ним обоим).   
> При этом сами k подмассивов рассматриваются как отсортированные последовательности разной длины, которые просто выдают очередной, текущий элемент (например, запросом очередного элемента по сети), к их следующим элементам мы доступ обычно не имеем.

Сам алгоритм:

1. Загружаем k текущих значений (по одному очередному из всех k подмассивов) в кучу. При этом храним для каждого элемента в куче не только значение, но и номер его подмассива.  
2. Выбираем максимальный элемент из кучи, выдаём его в результирующий массив. Из подмассива, в котором был этот элемент, извлекаем очередной элемент и добавляем в кучу. Такая операция потребует O(log k).  
3. Повторяем шаг 2, пока куча непустая.
В ситуации, когда n много больше, чем k (входных подмасивов немного, и они длинные), итоговая сложность O(n * log k) стремится по сути к линейной O(n).